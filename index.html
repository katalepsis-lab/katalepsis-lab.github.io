<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Katalepsis Lab | Personal Macro Sandbox</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body data-page="home">
  <header>
    <div class="nav" id="siteNav">
      <a class="logo" href="index.html#home">
        <div class="logo-mark" aria-hidden="true"></div>
        <div>
          <span class="brand">Katalepsis Lab</span>
          <span class="tagline">Macro research sandbox</span>
        </div>
      </a>
      <button class="nav-toggle" aria-label="Toggle navigation" id="navToggle">Menu</button>
      <nav class="nav-links" aria-label="Primary">
        <a class="nav-link" data-page="home" href="index.html#home">Home</a>
        <a class="nav-link" data-page="dashboards" href="index.html#dashboards">Dashboards</a>
        <a class="nav-link" data-page="chatbot" href="index.html#chatbot">Chatbot</a>
        <a class="nav-link" data-page="optimizer" href="optimizer.html">Optimizer</a>
        <a class="nav-link" data-page="cv" href="cv.html">CV</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="hero" id="home">
      <div>
        <div class="eyebrow"><span class="dot"></span><span>Personal macro lab</span></div>
        <h1>Katalepsis Lab · Macro dashboards, portfolio sandboxes, zero sales pitch.</h1>
        <p class="lede">A place where I tinker with data pipelines, macro dashboards, and portfolio optimizers. Everything here is experimental, educational, and actively changing.</p>
        <div class="hero-cta">
          <a class="btn btn-primary" href="#dashboards">View dashboards</a>
          <a class="btn" href="#chatbot">Try the chatbot</a>
        </div>
        <div class="chips">
          <span class="pill">Macro data plumbing</span>
          <span class="pill">Regime detection experiments</span>
          <span class="pill">Portfolio sandbox</span>
        </div>
        <div class="about-block">
          <strong>About the project:</strong>
          <p style="margin: 8px 0 0;">Learning in public by building my own tools. No clients, no sales funnel—just a working bench for macro dashboards and portfolio ideas. Not investment advice.</p>
        </div>
      </div>
      <div class="panel hero-panel">
        <div>
          <h3 style="margin: 0 0 8px;">What I'm building</h3>
          <div class="chips">
            <span class="pill">Data pipelines</span>
            <span class="pill">Nowcast dashboards</span>
            <span class="pill">Portfolio experiments</span>
            <span class="pill">Notes & docs</span>
          </div>
        </div>
        <div class="grid-two">
          <div class="tile">
            <div class="label">Current focus</div>
            <div class="value">US + Canada macro plumbing</div>
          </div>
          <div class="tile">
            <div class="label">Working principle</div>
            <div class="value">Evidence over hype. Ship small.</div>
          </div>
        </div>
      </div>
    </section>

    <section id="dashboards">
      <div class="section-header">
        <div>
          <h2>Macro Dashboards</h2>
          <p>Work in progress: country-level macro dashboards covering fiscal and monetary policy variables alongside core economic indicators. UI is being scaffolded while data pipelines firm up.</p>
        </div>
        <span class="status">Status: data plumbing nearly ready</span>
      </div>

      <div class="cards">
        <article class="card">
          <h3>United States</h3>
          <p>Growth, inflation, policy stance, term structure, liquidity, and market tone. Built for quick regime reads.</p>
          <span class="status">Status: data pipeline almost ready, UI under construction.</span>
          <div class="tiles">
            <div class="tile">
              <div class="label">Growth Nowcast</div>
              <div class="value">Last updated: coming soon</div>
            </div>
            <div class="tile">
              <div class="label">Inflation Pulse</div>
              <div class="value">Sticky CPI, PCE preview</div>
            </div>
            <div class="tile">
              <div class="label">Curve & Term Premium</div>
              <div class="value">Filling in estimates</div>
            </div>
            <div class="tile">
              <div class="label">Risk Appetite</div>
              <div class="value">Equity breadth + credit</div>
            </div>
          </div>
        </article>

        <article class="card">
          <h3>Canada</h3>
          <p>Housing, labor market, BoC path, regional spreads, and market breadth. Built to sense turning points early.</p>
          <span class="status">Status: data pipeline almost ready, UI under construction.</span>
          <div class="tiles">
            <div class="tile">
              <div class="label">Housing Pulse</div>
              <div class="value">Inventory & affordability</div>
            </div>
            <div class="tile">
              <div class="label">Labor Market</div>
              <div class="value">Unemployment & wage trend</div>
            </div>
            <div class="tile">
              <div class="label">BoC Path</div>
              <div class="value">Market-implied cuts</div>
            </div>
            <div class="tile">
              <div class="label">Spreads & Breakevens</div>
              <div class="value">Coming soon</div>
            </div>
          </div>
        </article>
      </div>

      <div class="note">These dashboards are personal research tools. They are not trading recommendations.</div>
    </section>

    <section id="tactical-allocation">
      <div class="section-header">
        <div>
          <h2>Tactical Allocation Dashboards</h2>
          <p>US and Canada tactical allocation views focused on valuations, central bank policy, term and credit spreads, GDP growth, and inflation expectations.</p>
        </div>
        <span class="status">Status: scoping in progress</span>
      </div>

      <div class="cards">
        <article class="card">
          <h3>United States</h3>
          <p>Signal stack for tactical tilts across rates, credit, and equities. Built for allocation timing, not just regime context.</p>
          <span class="status">Status: indicators defined, pipeline build next.</span>
          <div class="tiles">
            <div class="tile">
              <div class="label">Valuations</div>
              <div class="value">Equities, rates, credit comps</div>
            </div>
            <div class="tile">
              <div class="label">Central Bank Policy</div>
              <div class="value">Fed path + balance sheet</div>
            </div>
            <div class="tile">
              <div class="label">Term & Credit Spreads</div>
              <div class="value">Curve slope + HY/IG</div>
            </div>
            <div class="tile">
              <div class="label">GDP Growth</div>
              <div class="value">Nowcast + revisions</div>
            </div>
            <div class="tile">
              <div class="label">Inflation Expectations</div>
              <div class="value">Breakevens + surveys</div>
            </div>
          </div>
        </article>

        <article class="card">
          <h3>Canada</h3>
          <p>Tactical allocation lens for rates, credit, and equity risk. Emphasis on valuation gaps and policy transmission.</p>
          <span class="status">Status: indicators defined, pipeline build next.</span>
          <div class="tiles">
            <div class="tile">
              <div class="label">Valuations</div>
              <div class="value">Equities, rates, credit comps</div>
            </div>
            <div class="tile">
              <div class="label">Central Bank Policy</div>
              <div class="value">BoC path + liquidity</div>
            </div>
            <div class="tile">
              <div class="label">Term & Credit Spreads</div>
              <div class="value">Curve slope + credit risk</div>
            </div>
            <div class="tile">
              <div class="label">GDP Growth</div>
              <div class="value">Nowcast + revisions</div>
            </div>
            <div class="tile">
              <div class="label">Inflation Expectations</div>
              <div class="value">Breakevens + surveys</div>
            </div>
          </div>
        </article>
      </div>

      <div class="note">These dashboards are personal research tools. They are not trading recommendations.</div>
    </section>

    <section id="chatbot">
      <div class="section-header">
        <div>
          <h2>Portfolio Management Chatbot</h2>
          <p>A personal experiment that discusses allocations, risk, and macro views. Front-end only—connects to a Python backend you host elsewhere. Not financial advice.</p>
        </div>
        <span class="status">Experiment</span>
      </div>

      <div class="chat-grid">
        <div class="panel chat-config">
          <div>
            <h3 style="margin: 0 0 6px;">Connection</h3>
            <p class="help">Point this UI at your backend endpoint. Defaults to a placeholder.</p>
          </div>
          <div>
            <label for="backendUrl">Backend URL</label>
            <input type="text" id="backendUrl" name="backendUrl" aria-label="Backend URL" />
            <p class="help">Change to your Python service endpoint (POST). <!-- Update this value to your real backend URL. --></p>
          </div>
          <div>
            <label for="apiKey">OpenAI API key (optional)</label>
            <input type="password" id="apiKey" name="apiKey" aria-label="OpenAI API key" autocomplete="off" />
            <p class="help">Your key is kept in this browser only so requests can include it. Nothing is logged. Using your key will disable the strict rate limit.</p>
          </div>
        </div>

        <div class="chat-window">
          <div class="chat-messages" id="chatMessages" aria-live="polite"></div>
          <div class="chat-input">
            <form id="chatForm" style="display: contents;">
              <textarea id="chatMessage" name="chatMessage" placeholder="Ask about allocations, risk, or a macro view..." aria-label="Message"></textarea>
              <button type="submit" class="btn btn-primary" id="sendBtn">Send</button>
            </form>
          </div>
          <div class="error" id="chatError" role="alert" aria-live="assertive"></div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div class="nav" style="padding: 0; max-width: 1100px;">
      <div>
        <strong>Katalepsis Lab</strong>
        <div class="help">All content is for research and educational purposes. Nothing here is investment advice.</div>
      </div>
      <div class="help">Built as a personal lab for macro dashboards & portfolio tools.<br>
        Front-end scaffolding originally generated with Codex (OpenAI).</div>
    </div>
  </footer>

  <script>
    const navToggle = document.getElementById("navToggle");
    const siteNav = document.getElementById("siteNav");
    navToggle?.addEventListener("click", () => {
      siteNav.classList.toggle("open");
    });

    // Highlight the active nav item based on the current page
    const activePage = document.body?.dataset?.page;
    document.querySelectorAll(".nav-link").forEach((link) => {
      if (link.dataset.page === activePage) {
        link.classList.add("active");
      }
      link.addEventListener("click", () => siteNav.classList.remove("open"));
    });

    // Update this to point to your actual Python backend.
    const DEFAULT_BACKEND_URL = "https://katalepsis-lab.app.n8n.cloud/webhook/chat"; // This is the testing webhook, change for prod.
    const backendUrlInput = document.getElementById("backendUrl");
    backendUrlInput.value = DEFAULT_BACKEND_URL;

    const apiKeyInput = document.getElementById("apiKey");
    const chatMessagesEl = document.getElementById("chatMessages");
    const chatForm = document.getElementById("chatForm");
    const chatMessageInput = document.getElementById("chatMessage");
    const chatError = document.getElementById("chatError");
    const sendBtn = document.getElementById("sendBtn");

    const storedKey = window.localStorage.getItem("katalepsis-openai-key");
    if (storedKey) apiKeyInput.value = storedKey;

    const RATE_LIMIT_COUNT = 25;
    const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; // 1 hour
    const RATE_LIMIT_STORAGE_KEY = "katalepsis-rate-limit";

    function loadRateLimit() {
      try {
        const raw = window.localStorage.getItem(RATE_LIMIT_STORAGE_KEY);
        const parsed = raw ? JSON.parse(raw) : [];
        return Array.isArray(parsed) ? parsed : [];
      } catch (_) {
        return [];
      }
    }

    function saveRateLimit(stamps) {
      try {
        window.localStorage.setItem(RATE_LIMIT_STORAGE_KEY, JSON.stringify(stamps));
      } catch (_) {
        // ignore storage errors
      }
    }

    function pruneRateLimit(stamps) {
      const now = Date.now();
      return stamps.filter((ts) => now - ts < RATE_LIMIT_WINDOW_MS);
    }

    const messages = [
      {
        role: "assistant",
        text: "Hi - this is a portfolio management chatbot experiment. I can discuss allocations, risk budgets, and macro narratives. Not investment advice."
      }
    ];

    function renderMessages() {
      chatMessagesEl.innerHTML = messages.map((msg) => {
        const side = msg.role === "user" ? "user" : "assistant";
        return '<div class="message ' + side + '"><div class="bubble">' + renderMarkdownSafe(msg.text) + "</div></div>";
      }).join("");
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }

    function escapeHtml(unsafe) {
      return unsafe.replace(/[&<>"']/g, (m) => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#039;"
      }[m]));
    }

    function renderMarkdownSafe(raw) {
      const codeBlocks = [];
      let text = (raw || "").replace(/\r\n?/g, "\n");

      text = text.replace(/```(\w+)?\n?([\s\S]*?)```/g, (_, lang, code) => {
        const language = lang ? lang.trim() : "";
        const escapedCode = escapeHtml(code.trim());
        const placeholder = "@@CODEBLOCK" + codeBlocks.length + "@@";
        const langAttr = language ? ' data-lang="' + escapeHtml(language) + '"' : "";
        const classAttr = language ? ' class="language-' + escapeHtml(language) + '"' : "";
        codeBlocks.push('<pre class="code-block"' + langAttr + '><code' + classAttr + ">" + escapedCode + "</code></pre>");
        return placeholder;
      });

      text = escapeHtml(text);
      text = text.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');
      text = text.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
      text = text.replace(/\*(.+?)\*/g, "<em>$1</em>");

      const lines = text.split("\n");
      const htmlParts = [];
      let inList = false;
      const flushList = () => {
        if (inList) {
          htmlParts.push("</ul>");
          inList = false;
        }
      };

      const parseCells = (row) => row.split("|").map((c) => c.trim()).filter((c, i, arr) => !(i === 0 && c === "") && !(i === arr.length - 1 && c === ""));

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        const headingMatch = line.match(/^\s*(#{1,6})\s+(.*)/);
        if (headingMatch) {
          flushList();
          const level = Math.min(headingMatch[1].length, 6);
          htmlParts.push("<h" + level + ">" + headingMatch[2].trim() + "</h" + level + ">");
          continue;
        }

        if (/^\s*[-*_]{3,}\s*$/.test(line)) {
          flushList();
          htmlParts.push('<hr class="md-hr">');
          continue;
        }

        const nextLine = lines[i + 1];
        if (nextLine && /\|/.test(line) && /^\s*\|?\s*:?-{3,}/.test(nextLine)) {
          flushList();
          const headerCells = parseCells(line);
          const bodyRows = [];
          i += 2;
          while (i < lines.length && /\|/.test(lines[i]) && !/^\s*$/.test(lines[i])) {
            bodyRows.push(parseCells(lines[i]));
            i++;
          }
          i -= 1;

          htmlParts.push('<table class="md-table"><thead><tr>' + headerCells.map((cell) => "<th>" + cell + "</th>").join("") + "</tr></thead>");
          htmlParts.push("<tbody>");
          bodyRows.forEach((row) => {
            htmlParts.push("<tr>" + row.map((cell) => "<td>" + cell + "</td>").join("") + "</tr>");
          });
          htmlParts.push("</tbody></table>");
          continue;
        }

        const listMatch = line.match(/^\s*[-*]\s+(.*)/);
        if (listMatch) {
          if (!inList) {
            htmlParts.push('<ul class="md-list">');
            inList = true;
          }
          htmlParts.push("<li>" + listMatch[1] + "</li>");
        } else if (line.trim() === "") {
          flushList();
          if (i !== lines.length - 1) htmlParts.push("<br>");
        } else {
          flushList();
          htmlParts.push("<p>" + line + "</p>");
        }
      }

      flushList();

      let html = htmlParts.join("");
      codeBlocks.forEach((block, idx) => {
        html = html.replace("@@CODEBLOCK" + idx + "@@", block);
      });

      return html;
    }

    async function sendMessageToBackend(message, openaiKey, backendUrl) {
      // Adjust field names here if your backend expects different keys.
      const payload = {
        message,
        openai_api_key: openaiKey || undefined
      };

      const response = await fetch(backendUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        let detail = "";
        try {
          const errData = await response.json();
          detail = errData?.detail || errData?.message || "";
        } catch (_) {
          try {
            detail = await response.text();
          } catch (_) {
            detail = "";
          }
        }
        const baseMsg = detail || "Backend returned " + response.status;
        if (response.status === 429) {
          throw new Error(
            detail || "Rate limit reached: 25 messages per hour without your own API key. Please add your key or come back later."
          );
        }
        throw new Error(baseMsg);
      }

      const data = await response.json();
      // Adjust the property used below if your backend returns a different shape.
      return data.reply || data.message || "Response received (adjust parsing to match your backend).";
    }

    chatMessageInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && !event.shiftKey && !event.isComposing) {
        event.preventDefault();
        if (!sendBtn.disabled) {
          // Use form submission so the existing handler runs.
          chatForm.requestSubmit();
        }
      }
    });

    chatForm.addEventListener("submit", async (event) => {
      event.preventDefault();
      const text = chatMessageInput.value.trim();
      if (!text) return;

      chatError.textContent = "";
      const backendUrl = backendUrlInput.value.trim() || DEFAULT_BACKEND_URL;
      const openaiKey = apiKeyInput.value.trim();
      if (openaiKey) {
        window.localStorage.setItem("katalepsis-openai-key", openaiKey);
      } else {
        window.localStorage.removeItem("katalepsis-openai-key");
      }

      if (!openaiKey) {
        let stamps = pruneRateLimit(loadRateLimit());
        if (stamps.length >= RATE_LIMIT_COUNT) {
          const limitMsg = "Rate limit reached: 25 messages per hour without your own API key. Please add your key or try again later.";
          messages.push({ role: "assistant", text: limitMsg });
          chatError.textContent = "Error: " + limitMsg;
          renderMessages();
          return;
        }
        stamps.push(Date.now());
        saveRateLimit(stamps);
      }

      messages.push({ role: "user", text });
      renderMessages();
      chatMessageInput.value = "";
      sendBtn.disabled = true;
      sendBtn.textContent = "Thinking...";

      try {
        const reply = await sendMessageToBackend(text, openaiKey, backendUrl);
        messages.push({ role: "assistant", text: reply });
      } catch (err) {
        const friendly = err && err.message ? err.message : "Unable to reach backend";
        messages.push({ role: "assistant", text: friendly });
        chatError.textContent = "Error: " + friendly;
      } finally {
        sendBtn.disabled = false;
        sendBtn.textContent = "Send";
        renderMessages();
      }
    });

    renderMessages();
  </script>
</body>
</html>
